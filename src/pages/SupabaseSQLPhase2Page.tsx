import { useState } from "react";
import { CheckCircle, XCircle, Clock, Copy, Database, Shield, Radio, Edit } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/hooks/use-toast";
import { useSupabaseAuth } from "@/hooks/useSupabaseAuth";
import { supabase } from "@/integrations/supabase/client";

type CheckStatus = "idle" | "running" | "success" | "error";

interface VerificationCheck {
  id: string;
  label: string;
  icon: React.ComponentType<any>;
  status: CheckStatus;
  message?: string;
}

const SQL_SCHEMA = `-- Extensions (pgcrypto usually enabled by default)
create extension if not exists pgcrypto;

-- RUNS
create table if not exists public.runs (
  id uuid primary key default gen_random_uuid(),
  owner uuid not null references auth.users(id),
  scenario_id text,
  profile_id text references public.userai_profiles(id),
  story_mode boolean default true,
  max_turns int not null,
  started_at timestamptz default now(),
  finished_at timestamptz
);

-- TURNS
create table if not exists public.turns (
  id bigint generated by default as identity primary key,
  run_id uuid not null references public.runs(id) on delete cascade,
  turn_index int not null,
  speaker text not null check (speaker in ('Nini','USERAI')),
  text text not null,
  beat jsonb,
  short_memory jsonb,
  created_at timestamptz default now()
);

-- TURN METRICS
create table if not exists public.turn_metrics (
  turn_id bigint primary key references public.turns(id) on delete cascade,
  chars int,
  paragraphs int,
  questions int,
  emotions text[],
  needs text[],
  boundaries text[]
);

-- TURN SAFETY
create table if not exists public.turn_safety (
  turn_id bigint primary key references public.turns(id) on delete cascade,
  matched text[],
  escalated boolean
);

-- EVENTS (Unified Log)
create table if not exists public.events (
  id bigint generated by default as identity primary key,
  ts timestamptz default now(),
  level text,         -- INFO | WARN | ERROR | DEBUG
  type text,          -- LLM.ERROR, RUN.START, TURN.END, etc.
  severity text,      -- LOW | MEDIUM | HIGH
  trace_id uuid,
  run_id uuid,
  turn_index int,
  scenario_id text,
  profile_id text,
  meta jsonb,
  state text default 'OPEN',  -- OPEN | ACK | RESOLVED
  tags text[],
  owner uuid not null references auth.users(id)
);

-- RLS enable
alter table public.runs enable row level security;
alter table public.turns enable row level security;
alter table public.turn_metrics enable row level security;
alter table public.turn_safety enable row level security;
alter table public.events enable row level security;

-- RLS policies (owner can RW)
drop policy if exists "runs_rw_owner" on public.runs;
create policy "runs_rw_owner" on public.runs
  for all using (owner = auth.uid()) with check (owner = auth.uid());

drop policy if exists "turns_rw_owner" on public.turns;
create policy "turns_rw_owner" on public.turns
  for all using (
    exists (select 1 from public.runs r where r.id = run_id and r.owner = auth.uid())
  ) with check (
    exists (select 1 from public.runs r where r.id = run_id and r.owner = auth.uid())
  );

drop policy if exists "turn_metrics_rw_owner" on public.turn_metrics;
create policy "turn_metrics_rw_owner" on public.turn_metrics
  for all using (
    exists (select 1 from public.turns t join public.runs r on t.run_id = r.id where t.id = turn_id and r.owner = auth.uid())
  ) with check (
    exists (select 1 from public.turns t join public.runs r on t.run_id = r.id where t.id = turn_id and r.owner = auth.uid())
  );

drop policy if exists "turn_safety_rw_owner" on public.turn_safety;
create policy "turn_safety_rw_owner" on public.turn_safety
  for all using (
    exists (select 1 from public.turns t join public.runs r on t.run_id = r.id where t.id = turn_id and r.owner = auth.uid())
  ) with check (
    exists (select 1 from public.turns t join public.runs r on t.run_id = r.id where t.id = turn_id and r.owner = auth.uid())
  );

drop policy if exists "events_rw_owner" on public.events;
create policy "events_rw_owner" on public.events
  for all using (owner = auth.uid()) with check (owner = auth.uid());

-- Indexes
create index if not exists idx_runs_owner_started on public.runs(owner, started_at desc);
create index if not exists idx_turns_run_turn on public.turns(run_id, turn_index);
create index if not exists idx_events_owner_ts on public.events(owner, ts desc);
create index if not exists idx_events_type on public.events(type);
create index if not exists idx_events_http_status on public.events((meta->'http'->>'status'));

-- Realtime publication (add tables)
alter publication supabase_realtime add table public.events;
alter publication supabase_realtime add table public.runs;
alter publication supabase_realtime add table public.turns;`;

export default function SupabaseSQLPhase2Page() {
  const { toast } = useToast();
  const { user } = useSupabaseAuth();
  
  const [checks, setChecks] = useState<VerificationCheck[]>([
    {
      id: "tables",
      label: "Check Tables",
      icon: Database,
      status: "idle"
    },
    {
      id: "rls",
      label: "Check RLS",
      icon: Shield,
      status: "idle"
    },
    {
      id: "realtime",
      label: "Realtime Publication",
      icon: Radio,
      status: "idle"
    },
    {
      id: "write-test",
      label: "Write Test",
      icon: Edit,
      status: "idle"
    }
  ]);

  const updateCheckStatus = (id: string, status: CheckStatus, message?: string) => {
    setChecks(prev => prev.map(check => 
      check.id === id ? { ...check, status, message } : check
    ));
  };

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(SQL_SCHEMA);
      toast({
        title: "✅ SQL Copied",
        description: "Schema SQL copied to clipboard. Paste it in Supabase SQL Editor."
      });
    } catch (error) {
      toast({
        title: "❌ Copy Failed",
        description: "Could not copy to clipboard. Please select and copy manually.",
        variant: "destructive"
      });
    }
  };

  const checkTables = async () => {
    updateCheckStatus("tables", "running");
    
    const requiredTables = ['runs', 'turns', 'turn_metrics', 'turn_safety', 'events'];
    const results: string[] = [];
    
    try {
      for (const tableName of requiredTables) {
        try {
          const { data, error } = await (supabase as any).rpc('check_table_exists', { 
            table_name: tableName 
          });
          
          if (error) {
            // Fallback: try a simple select to check if table exists
            const { error: selectError } = await (supabase as any)
              .from(tableName)
              .select('1')
              .limit(1);
            
            if (selectError && selectError.code === '42P01') {
              throw new Error(`Table ${tableName} does not exist`);
            }
          }
          
          results.push(`✅ ${tableName}`);
        } catch (err: any) {
          if (err.message?.includes('does not exist') || err.code === '42P01') {
            results.push(`❌ ${tableName}`);
          } else {
            results.push(`✅ ${tableName} (accessible)`);
          }
        }
      }
      
      const failedTables = results.filter(r => r.includes('❌'));
      if (failedTables.length > 0) {
        updateCheckStatus("tables", "error", `Missing tables: ${failedTables.join(', ')}`);
        toast({
          title: "❌ Tables Check",
          description: `${failedTables.length} tables missing or inaccessible`,
          variant: "destructive"
        });
      } else {
        updateCheckStatus("tables", "success", `All ${requiredTables.length} tables found`);
        toast({
          title: "✅ Tables Check",
          description: `All required tables exist and are accessible`
        });
      }
    } catch (error: any) {
      updateCheckStatus("tables", "error", `Check failed: ${error.message}`);
      toast({
        title: "❌ Tables Check",
        description: `Failed to check tables: ${error.message}`,
        variant: "destructive"
      });
    }
  };

  const checkRLS = async () => {
    updateCheckStatus("rls", "running");
    
    try {
      const { data, error } = await (supabase as any)
        .from('pg_class')
        .select('relname, relrowsecurity')
        .in('relname', ['runs', 'turns', 'turn_metrics', 'turn_safety', 'events']);
        
      if (error) throw error;
      
      const rlsEnabled = data?.filter((table: any) => table.relrowsecurity) || [];
      const rlsDisabled = data?.filter((table: any) => !table.relrowsecurity) || [];
      
      if (rlsDisabled.length > 0) {
        updateCheckStatus("rls", "error", `RLS disabled on: ${rlsDisabled.map((t: any) => t.relname).join(', ')}`);
        toast({
          title: "❌ RLS Check",
          description: `${rlsDisabled.length} tables have RLS disabled`,
          variant: "destructive"
        });
      } else {
        updateCheckStatus("rls", "success", `RLS enabled on all ${rlsEnabled.length} tables`);
        toast({
          title: "✅ RLS Check",
          description: `Row Level Security is enabled on all tables`
        });
      }
    } catch (error: any) {
      updateCheckStatus("rls", "error", `RLS check failed: ${error.message}`);
      toast({
        title: "❌ RLS Check",
        description: `Cannot verify RLS status: ${error.message}`,
        variant: "destructive"
      });
    }
  };

  const checkRealtimePublication = async () => {
    updateCheckStatus("realtime", "running");
    
    try {
      const { data, error } = await (supabase as any)
        .from('pg_publication_tables')
        .select('tablename')
        .eq('pubname', 'supabase_realtime')
        .in('tablename', ['events', 'runs', 'turns']);
        
      if (error) throw error;
      
      const publishedTables = data?.map((row: any) => row.tablename) || [];
      const requiredTables = ['events', 'runs', 'turns'];
      const missingTables = requiredTables.filter(table => !publishedTables.includes(table));
      
      if (missingTables.length > 0) {
        updateCheckStatus("realtime", "error", `Missing from publication: ${missingTables.join(', ')}`);
        toast({
          title: "❌ Realtime Publication",
          description: `${missingTables.length} tables not in supabase_realtime publication`,
          variant: "destructive"
        });
      } else {
        updateCheckStatus("realtime", "success", `All ${publishedTables.length} tables in realtime publication`);
        toast({
          title: "✅ Realtime Publication",
          description: `All required tables are published for realtime updates`
        });
      }
    } catch (error: any) {
      updateCheckStatus("realtime", "error", `Publication check failed: ${error.message}`);
      toast({
        title: "❌ Realtime Publication",
        description: `Cannot verify publication: ${error.message}`,
        variant: "destructive"
      });
    }
  };

  const runWriteTest = async () => {
    updateCheckStatus("write-test", "running");
    
    if (!user) {
      updateCheckStatus("write-test", "error", "Authentication required");
      toast({
        title: "❌ Write Test",
        description: "Please sign in to run write test",
        variant: "destructive"
      });
      return;
    }

    let runId: string | null = null;
    
    try {
      // Insert test run
      const { data: runData, error: runError } = await (supabase as any)
        .from('runs')
        .insert({
          owner: user.id,
          scenario_id: 'test_scenario',
          max_turns: 1,
          story_mode: true
        })
        .select('id')
        .single();
      
      if (runError) throw new Error(`Run insert failed: ${runError.message}`);
      
      runId = runData.id;
      
      // Insert test turn
      const { error: turnError } = await (supabase as any)
        .from('turns')
        .insert({
          run_id: runId,
          turn_index: 1,
          speaker: 'Nini',
          text: 'Test message for validation'
        });
      
      if (turnError) throw new Error(`Turn insert failed: ${turnError.message}`);
      
      // Clean up - delete the test data
      const { error: deleteRunError } = await (supabase as any)
        .from('runs')
        .delete()
        .eq('id', runId)
        .eq('owner', user.id);
      
      if (deleteRunError) throw new Error(`Cleanup failed: ${deleteRunError.message}`);
      
      updateCheckStatus("write-test", "success", "Insert and delete operations successful");
      toast({
        title: "✅ Write Test",
        description: "Successfully tested insert and delete operations"
      });
      
    } catch (error: any) {
      // Attempt cleanup if runId exists
      if (runId) {
        try {
          await (supabase as any)
            .from('runs')
            .delete()
            .eq('id', runId)
            .eq('owner', user.id);
        } catch (cleanupError) {
          console.error('Cleanup error:', cleanupError);
        }
      }
      
      updateCheckStatus("write-test", "error", `Write test failed: ${error.message}`);
      toast({
        title: "❌ Write Test",
        description: `Write operations failed: ${error.message}`,
        variant: "destructive"
      });
    }
  };

  const getStatusIcon = (status: CheckStatus) => {
    switch (status) {
      case "success":
        return <CheckCircle className="h-4 w-4 text-green-600" />;
      case "error":
        return <XCircle className="h-4 w-4 text-red-600" />;
      case "running":
        return <Clock className="h-4 w-4 text-yellow-600 animate-spin" />;
      default:
        return <div className="h-4 w-4 rounded-full border-2 border-muted-foreground/30" />;
    }
  };

  const getStatusBadge = (status: CheckStatus) => {
    switch (status) {
      case "success":
        return <Badge variant="outline" className="text-green-600 border-green-600">✅ Pass</Badge>;
      case "error":
        return <Badge variant="outline" className="text-red-600 border-red-600">❌ Fail</Badge>;
      case "running":
        return <Badge variant="outline" className="text-yellow-600 border-yellow-600">⏳ Running</Badge>;
      default:
        return <Badge variant="outline" className="text-muted-foreground">Pending</Badge>;
    }
  };

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Supabase SQL – Phase 2</h1>
        <p className="text-muted-foreground mt-2">
          Copy this SQL, run it in the Supabase SQL Editor, then click 'Verify' below to test the schema.
        </p>
      </div>

      {/* SQL Schema Display */}
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle className="flex items-center gap-2">
              <Database className="h-5 w-5" />
              Phase 2 Schema SQL
            </CardTitle>
            <Button onClick={copyToClipboard} variant="outline">
              <Copy className="h-4 w-4 mr-2" />
              Copy SQL
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <pre className="bg-muted p-4 rounded-lg text-sm overflow-x-auto whitespace-pre-wrap">
            {SQL_SCHEMA}
          </pre>
        </CardContent>
      </Card>

      {/* Verification Panel */}
      <Card>
        <CardHeader>
          <CardTitle>Verification Panel</CardTitle>
          <p className="text-sm text-muted-foreground">
            After running the SQL in Supabase, use these buttons to verify everything is working correctly.
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          {checks.map((check, index) => {
            const IconComponent = check.icon;
            
            const handleCheckClick = () => {
              switch (check.id) {
                case "tables":
                  checkTables();
                  break;
                case "rls":
                  checkRLS();
                  break;
                case "realtime":
                  checkRealtimePublication();
                  break;
                case "write-test":
                  runWriteTest();
                  break;
              }
            };
            
            return (
              <div key={check.id}>
                <div className="flex items-center justify-between p-3 border rounded-lg">
                  <div className="flex items-center gap-3">
                    <IconComponent className="h-4 w-4 text-muted-foreground" />
                    <div className="flex-1">
                      <div className="font-medium">{check.label}</div>
                      {check.message && (
                        <div className="text-sm text-muted-foreground">{check.message}</div>
                      )}
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    {getStatusBadge(check.status)}
                    
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={handleCheckClick}
                      disabled={check.status === "running"}
                    >
                      {check.status === "running" ? "Checking..." : "Verify"}
                    </Button>
                  </div>
                </div>
                
                {index < checks.length - 1 && <Separator className="my-2" />}
              </div>
            );
          })}
        </CardContent>
      </Card>

      {/* Status Summary */}
      <Card>
        <CardHeader>
          <CardTitle>Schema Overview</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
            <div>
              <div className="font-medium">Tables</div>
              <div className="text-muted-foreground">runs, turns, turn_metrics, turn_safety, events</div>
            </div>
            <div>
              <div className="font-medium">Security</div>
              <div className="text-muted-foreground">Row Level Security (RLS) on all tables</div>
            </div>
            <div>
              <div className="font-medium">Realtime</div>
              <div className="text-muted-foreground">Publication for events, runs, turns</div>
            </div>
          </div>
          
          <div className="pt-2 border-t">
            <div className="font-medium text-sm mb-2">Key Features:</div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs text-muted-foreground">
              <div>• Owner-based access control via RLS</div>
              <div>• Cascading deletes for data integrity</div>
              <div>• Optimized indexes for performance</div>
              <div>• Real-time updates for live monitoring</div>
              <div>• Unified events table for observability</div>
              <div>• JSONB fields for flexible metadata</div>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}